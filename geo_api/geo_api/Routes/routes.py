
from flask import Flask, Response
from flask import Blueprint, request, jsonify
import io
from PIL import Image
import numpy as np
from autogenerated_files import ring_master_pb2_grpc as ringpbgrpc
from autogenerated_files import ring_master_pb2 as ringpb
from client_wrapper import ServiceClient
from routes_config import BLUE_PRINT_KEY, SERVER_STUB, SERVER_PORT, LENTRA_AUTHENTICATION_FLAG, \
    LENTRA_AUTH_USER, LENTRA_PASSWORD, VERSION_V1, VERSION_V2,VERSION_V3, IQA_V1, IQA_V2, VERSION_V3, IQA_V3,IMAGE_MODE,VERSION_V4,CREDIT_CSV_PATH

from google.protobuf.json_format import MessageToDict, MessageToJson
from utils import route_utils
from utils import service_schema
from utils import constants
import base64
from werkzeug.exceptions import HTTPException
from time import perf_counter
from flask_cors import CORS, cross_origin
from pytools import memoize
import os
import grpc
from flask import send_file
import cv2
import  pandas as pd


grpc_map = Blueprint(BLUE_PRINT_KEY, __name__, url_prefix="/" + BLUE_PRINT_KEY)


def serve(ring_master_host):
    channel = grpc.insecure_channel('{0}:{1}'.format(ring_master_host, SERVER_PORT),
                                    options=[
                                        ('grpc.max_send_message_length', 50 * 1024 * 1024),
                                        ('grpc.max_receive_message_length', 50 * 1024 * 1024)
                                    ]
                                    )
    stub = ringpbgrpc.RingMasterServiceStub(channel)
    return stub


@memoize
def wsgiapp():
    app = Flask(__name__, instance_relative_config=True)
    app.register_blueprint(grpc_map)
    ring_master_host = os.environ.get('RMGRPC') if os.environ.get('RMGRPC') is not None else "localhost"
    # TODO will decide which one to use after testing
    app.config['grcp'] = ServiceClient(ringpbgrpc, SERVER_STUB, ring_master_host, SERVER_PORT)
    # app.config['grcp'] = serve(ring_master_host)

    return app


@grpc_map.route(VERSION_V1 + '/classifier', methods=['POST', 'OPTIONS'])
@cross_origin()  # allow all origins all methods.
def kycclassifier():
    if len(request.files) > 0:
        image = request.files['file']
        filename = image.filename
        is_valid_format, extension = route_utils.validate_file_formats(filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        if not image:
            return route_utils.set_no_file_response()
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        image_array = image.read()
        pil_image_format = Image.open(io.BytesIO(image_array))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(image_array)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        kyc_request = ringpb.kyc_doc_clf_request(
            document_image=img_bytes,
            image_width=w,
            image_height=h,
            image_channels=ch
        )
        doc_type = wsgiapp().config['grcp'].ClassifyKycDocument(kyc_request)
        return jsonify({'card_type': doc_type.document_type})
    else:
        return route_utils.set_no_file_response()


@grpc_map.route(VERSION_V1 + '/ocr', methods=['POST', 'OPTIONS'])
@cross_origin()  # allow all origins all methods.
def kycocr():
    if len(request.files) > 0:
        image = request.files['file']
        filename = image.filename
        is_valid_format, extension = route_utils.validate_file_formats(filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        card_type = ''
        if 'card_type' in request.form:
            card_type = request.form['card_type']

        if not image:
            return route_utils.set_no_file_response()

        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        image_array = image.read()
        pil_image_format = Image.open(io.BytesIO(image_array))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(image_array)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        ocr_request = ringpb.rm_kyc_ocr_request(
            doc_image=img_bytes,
            image_width=w,
            image_height=h,
            image_channels=ch,
            card_type=card_type
        )

        ocr_details = wsgiapp().config['grcp'].GetOcrDetails(ocr_request)
        """
        MessageToDict has been used to convert grpc response object to json
        """
        if ocr_details.response.status != constants.OK:
            result = route_utils.set_error_respone(MessageToDict(ocr_details.response))
        else:
            result = route_utils.set_kyc_ocr_response(MessageToDict(ocr_details.response))
        return result
    else:
        return route_utils.set_no_file_response()

@grpc_map.route(VERSION_V3 + '/ocr', methods=['POST', 'OPTIONS'])
@cross_origin()  # allow all origins all methods.
def kycocr_old():
    if len(request.files) > 0:
        image = request.files['file']
        filename = image.filename
        is_valid_format, extension = route_utils.validate_file_formats(filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        card_type = ''
        if 'card_type' in request.form:
            card_type = request.form['card_type']

        if not image:
            return route_utils.set_no_file_response()

        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        image_array = image.read()
        pil_image_format = Image.open(io.BytesIO(image_array))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(image_array)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        ocr_request = ringpb.rm_kyc_ocr_request(
            doc_image=img_bytes,
            image_width=w,
            image_height=h,
            image_channels=ch,
            card_type=card_type
        )

        ocr_details = wsgiapp().config['grcp'].GetOcrDetails_old(ocr_request)
        """
        MessageToDict has been used to convert grpc response object to json
        """
        if ocr_details.response.status != constants.OK:
            result = route_utils.set_error_respone(MessageToDict(ocr_details.response))
        else:
            result = route_utils.set_kyc_ocr_response(MessageToDict(ocr_details.response))
        return result
    else:
        return route_utils.set_no_file_response()
@grpc_map.route(VERSION_V1 + '/facematch', methods=['POST', 'OPTIONS'])
@cross_origin()  # allow all origins all methods.
def matchwithimgupload():
    if len(request.files) > 1:
        applicant = request.files['applicant_photo']
        document = request.files['document']
        app_filename = applicant.filename
        is_valid_format, extension = route_utils.validate_file_formats(app_filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"applicant file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        doc_filename = document.filename
        is_valid_format, extension = route_utils.validate_file_formats(doc_filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"applicant file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        if not applicant or not document:
            return route_utils.set_no_file_response()
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response

        app_img = applicant.read()
        doc_img = document.read()
        app_pil_image_format = Image.open(io.BytesIO(app_img))
        if not app_pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(app_pil_image_format)
            pil_image = Image.fromarray(image_array)
            applicant_image = np.array(pil_image)
        else:
            applicant_image = np.array(app_pil_image_format)

        doc_pil_image_format = Image.open(io.BytesIO(doc_img))

        if not doc_pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(doc_pil_image_format)
            pil_image = Image.fromarray(image_array)
            document_image = np.array(pil_image)
        else:
            document_image = np.array(doc_pil_image_format)
        if IMAGE_MODE == constants.BGR:
            applicant_image = cv2.cvtColor(applicant_image,cv2.COLOR_RGB2BGR)
            document_image = cv2.cvtColor(document_image, cv2.COLOR_RGB2BGR)
        applicant_image_bytes = applicant_image.flatten().tostring()
        document_image_bytes = document_image.flatten().tostring()
        try:
            app_h, app_w, app_ch = applicant_image.shape
            doc_h, doc_w, doc_ch = document_image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not app_ch == constants.IMAGE_CHANEEL or not doc_ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)

        app_image_validation = route_utils.validate_image_size(app_img)
        doc_image_validation = route_utils.validate_image_size(doc_img)
        if not app_image_validation or not doc_image_validation:
            return route_utils.set_image_size_exceeds_error()

        pos_match_request = ringpb.rm_kyc_matcher_request(
            applicant_image=applicant_image_bytes,
            document_image=document_image_bytes,
            applicant_img_width=app_w,
            applicant_img_height=app_h,
            applicant_img_channels=app_ch,

            document_img_width=doc_w,
            document_img_height=doc_h,
            document_img_channels=doc_ch
        )

        matching_details = wsgiapp().config['grcp'].GetKycPosMatch(pos_match_request)
        dict = MessageToDict(matching_details)
        if not 'distance' in dict and not 'error' in dict:
            dict['distance'] = matching_details.distance

        response = route_utils.set_pos_match_response(dict)

        return response
    else:
        return route_utils.set_no_file_response()


@grpc_map.route(VERSION_V1 + '/redact', methods=['POST', 'OPTIONS'])
@cross_origin()  # allow all origins all methods.
def imgmaskupload():
    if len(request.files) > 0:
        image = request.files['file']
        filename = image.filename
        is_valid_format, extension = route_utils.validate_file_formats(filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        if not image:
            return route_utils.set_no_file_response()
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        image_array = image.read()
        pil_image_format = Image.open(io.BytesIO(image_array))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(image_array)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        redaction_request = ringpb.rm_redaction_request(
            image_to_redact=img_bytes,
            image_width=w,
            image_height=h,
            image_channels=ch
        )
        redacted_image = wsgiapp().config['grcp'].RedactImage(redaction_request)
        if redacted_image.response.status != constants.OK:
            result = route_utils.set_error_respone(MessageToDict(redacted_image.response))
        else:
            rot_img_bytes = redacted_image.response.redacted_image
            h, w, ch = redacted_image.response.image_height, redacted_image.response.image_width, redacted_image.response.image_channels
            rot_img = np.frombuffer(rot_img_bytes, dtype=np.uint8).reshape([h, w, ch])
            im = Image.fromarray(rot_img)
            buff = io.BytesIO()
            im.save(buff, format="JPEG")
            encoded_string = base64.b64encode(buff.getvalue())
            result = {"masked_image": encoded_string.decode("utf-8")}
        return result
    else:
        return route_utils.set_no_file_response()


@grpc_map.route(IQA_V1 + '/iqa', methods=['POST', 'OPTIONS'])
@cross_origin()  # allow all origins all methods.
def check_image_quality():
    if len(request.files) > 0:
        image = request.files['file']
        filename = image.filename
        is_valid_format, extension = route_utils.validate_file_formats(filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        if not image:
            return route_utils.set_no_file_response()
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        image_array = image.read()
        pil_image_format = Image.open(io.BytesIO(image_array))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(image_array)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        iqa_request = ringpb.rm_iqa_request(
            image=img_bytes,
            img_width=w,
            img_height=h,
            img_channels=ch
        )

        iqa_details = wsgiapp().config['grcp'].IQAFitness(iqa_request)
        if 'error' in MessageToDict(iqa_details):
            response = route_utils.set_error(iqa_details.error)
        else:
            response = {'score': iqa_details.score, 'score_band': iqa_details.score_band,
                        'message': iqa_details.message, 'status_code': constants.OK}

        return response
    else:
        return route_utils.set_no_file_response()


@grpc_map.route(VERSION_V1 + '/image_liveness', methods=['POST'])
def check_liveness():
    if len(request.files) > 0:
        image = request.files['file']
        filename = image.filename
        is_valid_format, extension = route_utils.validate_file_formats(filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        if not image:
            return route_utils.set_no_file_response()
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        image_array = image.read()
        pil_image_format = Image.open(io.BytesIO(image_array))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(image_array)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        liveness_request = ringpb.rm_liveness_request(
            image=img_bytes,
            im_width=w,
            im_height=h,
            im_channels=ch
        )
        iiveness_details = wsgiapp().config['grcp'].GetImgLiveness(liveness_request)
        return {'live': iiveness_details.live, 'score': iiveness_details.score}
    else:
        return route_utils.set_no_file_response()


@grpc_map.route(VERSION_V1 + '/getfacebox', methods=['POST'])
def get_face_bounding_boxes():
    if len(request.files) > 0:
        image = request.files['file']
        filename = image.filename
        is_valid_format, extension = route_utils.validate_file_formats(filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        if not image:
            return route_utils.set_no_file_response()
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        image_array = image.read()
        pil_image_format = Image.open(io.BytesIO(image_array))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(image_array)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()
        if image_validation and (h * w * ch) > constants.ALLOWED_IMAGE_SIZE:
            image = route_utils.resize_image_size(h, w, ch, pil_image_format)
            img_bytes = image.flatten().tostring()
            h, w, ch = image.shape

        redaction_request = ringpb.rm_extractor_request(
            input_image=img_bytes,
            image_width=w,
            image_height=h,
            image_channels=ch
        )
        extracted_face_image = wsgiapp().config['grcp'].DetectFace(redaction_request)

        bb_boxes = extracted_face_image.boxes
        result = route_utils.set_bb_boxes(bb_boxes)
        return result
    else:
        return route_utils.set_no_file_response()


@grpc_map.route(VERSION_V1 + '/addressocr', methods=['POST'])
def kyaddcocr():
    if len(request.files) > 0:
        image = request.files['file']
        filename = image.filename
        is_valid_format, extension = route_utils.validate_file_formats(filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        if not image:
            return route_utils.set_no_file_response()
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        image_array = image.read()
        pil_image_format = Image.open(io.BytesIO(image_array))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(image_array)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        ocr_request = ringpb.rm_kyc_ocr_request(
            doc_image=img_bytes,
            image_width=w,
            image_height=h,
            image_channels=ch
        )
        ocr_details = wsgiapp().config['grcp'].GetOcrAddrsDetails(ocr_request)
        """
        MessageToDict has been used to convert grpc response object to json
        """
        if ocr_details.response.status != constants.OK:
            result = route_utils.set_error_respone(MessageToDict(ocr_details.response))
        else:
            result = route_utils.set_kyc_ocr_response(MessageToDict(ocr_details.response))
        return result
    else:
        return route_utils.set_no_file_response()


@grpc_map.route(VERSION_V1 + '/imagetobase64', methods=['POST'])
def imagetobye64():
    if len(request.files) > 0:
        image = request.files['file']
        filename = image.filename
        is_valid_format, extension = route_utils.validate_file_formats(filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        if not image:
            return route_utils.set_no_file_response()
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        image_array = image.read()
        pil_image_format = Image.open(io.BytesIO(image_array))
        image = np.array(pil_image_format)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)

        image_validation = route_utils.validate_image_size(image_array)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        image = np.frombuffer(img_bytes, dtype=np.uint8).reshape([h, w, ch])
        im = Image.fromarray(image)
        buff = io.BytesIO()
        if im.mode == constants.RGB:
            im.save(buff, format="JPEG")
        else:
            im.save(buff, format="PNG")
        encoded_string = base64.b64encode(buff.getvalue())
        return encoded_string


@grpc_map.route(VERSION_V1 + '/base64toimage', methods=['POST'])
def base64toimage():

    if LENTRA_AUTHENTICATION_FLAG:
        response = route_utils.authenticate_request(request)
        if response:
            return response
    content = request.get_json()
    base64string = content['baseb4strting']
    imgdata = base64.b64decode(base64string)
    pil_image_format = Image.open(io.BytesIO(imgdata))
    image = np.array(pil_image_format)
    im = Image.fromarray(image)
    buff = io.BytesIO()
    if im.mode == constants.RGB:
        im.save(buff, "JPEG")
        mimetype = 'image/jpeg'
    else:
        im.save(buff, "PNG")
        mimetype = 'image/png'

    buff.seek(0)
    return send_file(buff, mimetype=mimetype)

@grpc_map.route(VERSION_V1+'/concatenateimage',methods = ['POST'])
def concate():
    if len(request.files) > 1:
        front_image = request.files['front_image']
        back_image = request.files['back_image']
        front_image_filename = front_image.filename
        is_valid_format, extension = route_utils.validate_file_formats(front_image_filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"applicant file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        back_image_filename = back_image.filename
        is_valid_format, extension = route_utils.validate_file_formats(back_image_filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"applicant file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        if not front_image or not back_image:
            return route_utils.set_no_file_response()
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response

        front_img = front_image.read()
        back_img = back_image.read()
        front_pil_image_format = Image.open(io.BytesIO(front_img))
        front_image_array =  np.array(front_pil_image_format)
        back_pil_image_format = Image.open(io.BytesIO(back_img))
        back_image_array =np.array(back_pil_image_format)

        front_img,front_img_bytes,front_h,\
            front_w,front_ch=route_utils.image_operations(front_pil_image_format,front_image_array)
        front_edge_request = ringpb.rm_img_edge_request(
            image=front_img_bytes,
            image_width=front_w,
            image_height=front_h,
            image_channels=front_ch
        )
        front_img_responses = wsgiapp().config['grcp'].ImgEdgeDetection(front_edge_request)
        list_co_ordinates = front_img_responses.response.boxes
        front_img_bytes = front_img_responses.response.image
        front_h, front_w, front_ch = front_img_responses.response.image_height, front_img_responses.response.image_width, front_img_responses.response.image_channels
        front_croped_image = route_utils.egde_detector_response(list_co_ordinates,front_img_bytes,front_h, front_w, front_ch,front_image_array)

        back_img, back_img_bytes, back_h, \
        back_w, back_ch = route_utils.image_operations(back_pil_image_format, back_image_array)
        back_edge_request = ringpb.rm_img_edge_request(
            image=back_img_bytes,
            image_width=back_w,
            image_height=back_h,
            image_channels=back_ch
        )
        back_img_responses = wsgiapp().config['grcp'].ImgEdgeDetection(back_edge_request)
        list_co_ordinates = back_img_responses.response.boxes
        back_img_bytes = back_img_responses.response.image
        back_h, back_w, back_ch = back_img_responses.response.image_height, back_img_responses.response.image_width, \
                                     back_img_responses.response.image_channels
        back_croped_image = route_utils.egde_detector_response(list_co_ordinates, back_img_bytes, back_h, back_w,
                                                                back_ch, back_image_array)
        front = route_utils.expand2square(Image.fromarray(front_croped_image),(255, 255, 255))
        back = route_utils.expand2square(Image.fromarray(back_croped_image),(255, 255, 255))
        front_croped_image = np.array(front)
        back_croped_image = np.array(back)
        if constants.CONCAT_DIRECTION == constants.H:
            img = route_utils.hconcat_resize_min([front_croped_image, back_croped_image])
        if constants.CONCAT_DIRECTION == constants.V:
            img = route_utils.vconcat_resize_min([front_croped_image, back_croped_image])
        im = Image.fromarray(img)
        # TODO To use it for local use
        #im.save("/home/ssg0283/Desktop/c/concatenew"+"_"+constants.CONCAT_DIRECTION+".jpg")
        buff = io.BytesIO()
        if im.mode == constants.RGB:
            im.save(buff, "JPEG")
            mimetype = 'image/jpeg'
        else:
            im.save(buff, "PNG")
            mimetype = 'image/png'

        buff.seek(0)
        return send_file(buff, mimetype=mimetype)


@grpc_map.route(VERSION_V1+ '/aadhaarfrontback',methods = ['POST'])
def frontbackocrv1():
    if len(request.files) > 0:
        image = request.files['file']
        filename = image.filename
        is_valid_format, extension = route_utils.validate_file_formats(filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        if not image:
            return route_utils.set_no_file_response()
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        image_array = image.read()
        pil_image_format = Image.open(io.BytesIO(image_array))
        if not pil_image_format.mode == constants.RGB:
            image_array = route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(image_array)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        doc_front_image, doc_back__image = route_utils.split_image(image)
        doc_front_image_bytes = doc_front_image.flatten().tostring()
        doc_back_image_bytes = doc_back__image.flatten().tostring()
        front_h, front_w, front_ch = doc_front_image.shape
        back_h, back_w, back_ch = doc_back__image.shape

        ocr_front_back_request = ringpb.rm_back_front_ocr_request(
                doc_front_image=doc_front_image_bytes,
                doc_back_image=doc_back_image_bytes,
                doc_front_img_width=front_w,
                doc_front_img_height=front_h,
                doc_front_img_channels=front_ch,
                doc_back_img_width=back_w,
                doc_back_img_height=back_h,
                doc_back_img_channels=back_ch,
                card_type=constants.aadhaar
            )

        ocr_details = wsgiapp().config['grcp'].GetFrontBackOCR(ocr_front_back_request)
        """
        MessageToDict has been used to convert grpc response object to json
        """
        result = route_utils.set_ocr_front_back_response(MessageToDict(ocr_details.response))
        return result

@grpc_map.route('/iqa',methods = ['POST'])
def iqa_cumulative():
    if len(request.files) > 0:
        image = request.files['file']

        filename = image.filename
        is_valid_format, extension = route_utils.validate_file_formats(filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        if not image:
            return route_utils.set_no_file_response()
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        image_array = image.read()
        pil_image_format = Image.open(io.BytesIO(image_array))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(image_array)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        if constants.FIND_EDGE:
            iqa_request = ringpb.rm_iqa_request(
                image=img_bytes,
                img_width=w,
                img_height=h,
                img_channels=ch,
                call_edge_detector=True
            )
        else:
            iqa_request = ringpb.rm_iqa_request(
                image=img_bytes,
                img_width=w,
                img_height=h,
                img_channels=ch,
            )

        iqa_details = wsgiapp().config['grcp'].CumulativeIQA(iqa_request)
        if 'error' in MessageToDict(iqa_details):
            response = route_utils.set_error(iqa_details.error)
        else:
            # TODO add response for IQA
            response = iqa_details

        return jsonify(route_utils.modified_iqa_response(MessageToDict(response)))
        #return jsonify(MessageToDict(response))

    else:
        return route_utils.set_no_file_response()


@grpc_map.route(VERSION_V2 + '/ocr', methods=['POST'])
def ocrbyurl():
    try:
        assert request.method == 'POST'
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        content = request.get_json()
        if content['request'] != constants.OCR:
            invalid_request = {'error': {'message': "please provide correct request type as ocr"},
                               'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(invalid_request)
        try:
            client_request = service_schema.OcrRequestSchema().load(content)
        except Exception:
            error_response = {'error': {'message': "Not a valid URL"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        # extension = client_request['data']['url'].split("/")[-1].split('.')[-1]
        if not route_utils.validate_file_formats(client_request['data']['url']):
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        is_valid_format, extension = route_utils.validate_file_formats(client_request['data']['url'])
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        url1 = route_utils.get_image_UAT(client_request['data']['url'])
        img = url1.content
        if url1.status_code != constants.OK:
            error_response = {'error': {'message': "Could not fetch URL"}, 'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)

        pil_image_format = Image.open(io.BytesIO(img))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(img)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        ocr_request = ringpb.rm_kyc_ocr_request(
            doc_image=img_bytes,
            image_width=w,
            image_height=h,
            image_channels=ch
        )
        ocr_details = wsgiapp().config['grcp'].GetOcrDetails(ocr_request)
        """
        MessageToDict has been used to convert grpc response object to json
        """
        if ocr_details.response.status != constants.OK:
            result = route_utils.set_error_respone(MessageToDict(ocr_details.response))
        else:
            result = route_utils.set_kyc_ocr_response(MessageToDict(ocr_details.response))
        return result
    except HTTPException:
        error_response = {'error': {'message': "service not found"}, 'status': constants.BAD_REQUEST}
        return route_utils.set_error_respone(error_response)


@grpc_map.route(VERSION_V2 + '/classifier', methods=['POST'])
def kycclassifirebyurl():
    try:
        assert request.method == 'POST'
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        content = request.get_json()
        if content['request'] != constants.CLASSIFIER:
            invalid_request = {'error': {'message': "please provide correct request type as classifier"},
                               'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(invalid_request)
        try:
            client_request = service_schema.OcrRequestSchema().load(content)
        except Exception:
            error_response = {'error': {'message': "Not a valid URL"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        is_valid_format, extension = route_utils.validate_file_formats(client_request['data']['url'])
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        url1 = route_utils.get_image_UAT(client_request['data']['url'])
        img = url1.content
        if url1.status_code != constants.OK:
            error_response = {'error': {'message': "Could not fetch URL"}, 'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)

        pil_image_format = Image.open(io.BytesIO(img))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(img)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        kyc_request = ringpb.kyc_doc_clf_request(
            document_image=img_bytes,
            image_width=w,
            image_height=h,
            image_channels=ch
        )
        doc_type = wsgiapp().config['grcp'].ClassifyKycDocument(kyc_request)
        return jsonify({'card_type': doc_type.document_type})
    except HTTPException:
        error_response = {'error': {'message': "service not found"}, 'status': constants.BAD_REQUEST}
        return route_utils.set_error_respone(error_response)


@grpc_map.route(VERSION_V2 + '/redact', methods=['POST'])
def imagemask():
    try:
        assert request.method == 'POST'
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        content = request.get_json()
        if content['request'] != constants.REDACT:
            invalid_request = {'error': {'message': "please provide correct request type as redact"},
                               'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(invalid_request)
        client_request = service_schema.OcrRequestSchema().load(content)

        is_valid_format, extension = route_utils.validate_file_formats(client_request['data']['url'])
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        url1 = route_utils.get_image_UAT(client_request['data']['url'])
        img = url1.content
        if url1.status_code != constants.OK:
            error_response = {'error': {'message': "Could not fetch URL"}, 'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        pil_image_format = Image.open(io.BytesIO(img))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(img)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        redaction_request = ringpb.rm_redaction_request(
            image_to_redact=img_bytes,
            image_width=w,
            image_height=h,
            image_channels=ch
        )
        redacted_image = wsgiapp().config['grcp'].RedactImage(redaction_request)
        if redacted_image.response.status != constants.OK:
            result = route_utils.set_error_respone(MessageToDict(redacted_image.response))
        else:
            rot_img_bytes = redacted_image.response.redacted_image
            h, w, ch = redacted_image.response.image_height, redacted_image.response.image_width, redacted_image.response.image_channels
            rot_img = np.frombuffer(rot_img_bytes, dtype=np.uint8).reshape([h, w, ch])
            im = Image.fromarray(rot_img)
            buff = io.BytesIO()
            im.save(buff, format="JPEG")
            encoded_string = base64.b64encode(buff.getvalue())
            result = {"masked_image": encoded_string.decode("utf-8"), 'status_code': constants.OK}
        return result
    except HTTPException:
        error_response = {'error': {'message': "service not found"}, 'status': constants.BAD_REQUEST}
        return route_utils.set_error_respone(error_response)


@grpc_map.route(VERSION_V2 + '/facematch', methods=['POST'])
def facematch():
    try:
        assert request.method == 'POST'
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        content = request.get_json()
        if content['request'] != constants.FACEMATCH:
            invalid_request = {'error': {'message': "please provide correct request type as facematch"},
                               'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(invalid_request)
        try:
            client_request = service_schema.GonogoClientRequest().load(content)
        except Exception:
            error_response = {'error': {'message': "Not a valid URL"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        is_valid_format_app, extension = route_utils.validate_file_formats(client_request['data']['url_1'])
        if not is_valid_format_app:
            error_response = {'error': {'message': f"applicant file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        is_valid_format_doc, extension = route_utils.validate_file_formats(client_request['data']['url_2'])
        if not is_valid_format_doc:
            error_response = {'error': {'message': f"applicant file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)

        try:
            start = perf_counter()
            url1 = route_utils.get_image_UAT(client_request['data']['url_1'])
            url2 = route_utils.get_image_UAT(client_request['data']['url_2'])
            end = perf_counter()
            fetch_image_tat = end - start
            start_pixar = perf_counter()
            app_img = url1.content
            doc_img = url2.content
        except Exception:
            error_response = {'error': {'message': "Could not fetch URL"}, 'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        if url1.status_code != constants.OK or url2.status_code != constants.OK:
            error_response = {'error': {'message': "No image found on provided path"}, 'status': url1.status_code}
            return route_utils.set_error_respone(error_response)
        app_pil_image_format = Image.open(io.BytesIO(app_img))
        if not app_pil_image_format.mode == constants.RGB:
            image_array = route_utils.convert_to_RGB(app_pil_image_format)
            pil_image = Image.fromarray(image_array)
            applicant_image = np.array(pil_image)
        else:
            applicant_image = np.array(app_pil_image_format)

        doc_pil_image_format = Image.open(io.BytesIO(doc_img))

        if not doc_pil_image_format.mode == constants.RGB:
            image_array = route_utils.convert_to_RGB(doc_pil_image_format)
            pil_image = Image.fromarray(image_array)
            document_image = np.array(pil_image)
        else:
            document_image = np.array(doc_pil_image_format)
        if IMAGE_MODE == constants.BGR:
            applicant_image = cv2.cvtColor(applicant_image, cv2.COLOR_RGB2BGR)
            document_image = cv2.cvtColor(document_image, cv2.COLOR_RGB2BGR)
        applicant_image_bytes = applicant_image.flatten().tostring()
        document_image_bytes = document_image.flatten().tostring()
        try:
            app_h, app_w, app_ch = applicant_image.shape
            doc_h, doc_w, doc_ch = document_image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not app_ch == constants.IMAGE_CHANEEL or not doc_ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)

        app_image_validation = route_utils.validate_image_size(app_img)
        doc_image_validation = route_utils.validate_image_size(doc_img)
        if not app_image_validation or not doc_image_validation:
            return route_utils.set_image_size_exceeds_error()

        pos_match_request = ringpb.rm_kyc_matcher_request(
            applicant_image=applicant_image_bytes,
            document_image=document_image_bytes,
            applicant_img_width=app_w,
            applicant_img_height=app_h,
            applicant_img_channels=app_ch,

            document_img_width=doc_w,
            document_img_height=doc_h,
            document_img_channels=doc_ch
        )

        matching_details = wsgiapp().config['grcp'].GetKycPosMatch(pos_match_request)
        dict = MessageToDict(matching_details)
        if not 'distance' in dict and not 'error' in dict:
            dict['distance'] = matching_details.distance

        response = route_utils.set_pos_match_response(dict)

        end_pixar = perf_counter()
        pixar_tat = end_pixar - start_pixar
        tat_dict = {}
        tat_dict['fetch_image_tat'] = fetch_image_tat
        tat_dict['pixar_tat'] = pixar_tat
        response['tat'] = tat_dict
        return response
    except HTTPException:
        error_response = {'error': {'message': "service not found"}, 'status': constants.BAD_REQUEST}
        return route_utils.set_error_respone(error_response)


@grpc_map.route(IQA_V2 + '/iqa', methods=['POST'])
def imagequality():
    try:
        assert request.method == 'POST'
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        content = request.get_json()
        if content['request'] != constants.IQA:
            invalid_request = {'error': {'message': "please provide correct request type as ocr"},
                               'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(invalid_request)
        try:
            client_request = service_schema.OcrRequestSchema().load(content)
        except Exception:
            error_response = {'error': {'message': "Not a valid URL"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        is_valid_format, extension = route_utils.validate_file_formats(client_request['data']['url'])
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        url1 = route_utils.get_image_UAT(client_request['data']['url'])
        img = url1.content
        if url1.status_code != constants.OK:
            error_response = {'error': {'message': "Could not fetch URL"}, 'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)

        pil_image_format = Image.open(io.BytesIO(img))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(img)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        iqa_request = ringpb.rm_iqa_request(
            image=img_bytes,
            img_width=w,
            img_height=h,
            img_channels=ch
        )
        iqa_details = wsgiapp().config['grcp'].IQAFitness(iqa_request)
        if 'error' in MessageToDict(iqa_details):
            response = route_utils.set_error(iqa_details.error)
        else:
            response = {'score': iqa_details.score, 'score_band': iqa_details.score_band,
                        'message': iqa_details.message, 'status_code': constants.OK}

        return response

    except HTTPException:
        error_response = {'error': {'message': "service not found"}, 'status': constants.BAD_REQUEST}
        return route_utils.set_error_respone(error_response)


@grpc_map.route(VERSION_V3 + '/pan', methods=['POST'])
def ocrbyurlpan():
    try:
        assert request.method == 'POST'
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        content = request.get_json()
        if content['request'] != constants.OCR:
            invalid_request = {'error': {'message': "please provide correct request type as ocr"},
                               'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(invalid_request)
        try:
            client_request = service_schema.OcrRequestSchema().load(content)
        except Exception:
            error_response = {'error': {'message': "Not a valid URL"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)

        is_valid_format, extension = route_utils.validate_file_formats(client_request['data']['url'])
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)

        url1 = route_utils.get_image_UAT(client_request['data']['url'])
        img = url1.content
        if url1.status_code != constants.OK:
            error_response = {'error': {'message': "Could not fetch URL"}, 'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)

        pil_image_format = Image.open(io.BytesIO(img))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(img)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        ocr_request = ringpb.rm_kyc_ocr_request(
            doc_image=img_bytes,
            image_width=w,
            image_height=h,
            image_channels=ch,
            card_type=constants.pan
        )
        ocr_details = wsgiapp().config['grcp'].GetOcrDetailsPAN(ocr_request)
        """
        MessageToDict has been used to convert grpc response object to json
        """
        if ocr_details.response.status != constants.OK:
            result = route_utils.set_error_respone(MessageToDict(ocr_details.response))
        else:
            result = route_utils.set_kyc_ocr_response(MessageToDict(ocr_details.response))
        return result
    except HTTPException:
        error_response = {'error': {'message': "service not found"}, 'status': constants.BAD_REQUEST}
        return route_utils.set_error_respone(error_response)


@grpc_map.route(VERSION_V3 + '/aadhaar', methods=['POST'])
def ocrbyurlaadhaar():
    try:
        assert request.method == 'POST'
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        content = request.get_json()
        if content['request'] != constants.OCR:
            invalid_request = {'error': {'message': "please provide correct request type as ocr"},
                               'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(invalid_request)
        try:
            client_request = service_schema.GonogoClientRequest().load(content)
        except Exception:
            error_response = {'error': {'message': "Not a valid URL"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        is_valid_format_front, extension = route_utils.validate_file_formats(client_request['data']['url_1'])
        if not is_valid_format_front:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        is_valid_format_back, extension = route_utils.validate_file_formats(client_request['data']['url_2'])
        if not is_valid_format_back:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        start = perf_counter()
        url1 = route_utils.get_image_UAT(client_request['data']['url_1'])
        url2 = route_utils.get_image_UAT(client_request['data']['url_2'])
        end = perf_counter()
        if url1.status_code != constants.OK or url2.status_code != constants.OK:
            error_response = {'error': {'message': "No image found on provided path"}, 'status': url1.status_code}
            return route_utils.set_error_respone(error_response)
        start_pixar = perf_counter()
        doc_front_img = url1.content
        doc_back_img = url2.content

        doc_back_pil_image_format = Image.open(io.BytesIO(doc_back_img))

        doc_front_pil_image_format = Image.open(io.BytesIO(doc_front_img))
        if not doc_front_pil_image_format.mode == constants.RGB:
            image_array = route_utils.convert_to_RGB(doc_front_pil_image_format)
            pil_image = Image.fromarray(image_array)
            doc_front_image = np.array(pil_image)
        else:
            doc_front_image = np.array(doc_front_pil_image_format)

            doc_back_pil_image_format = Image.open(io.BytesIO(doc_back_img))

        if not doc_back_pil_image_format.mode == constants.RGB:
            image_array = route_utils.convert_to_RGB(doc_back_pil_image_format)
            pil_image = Image.fromarray(image_array)
            doc_back__image = np.array(pil_image)
        else:
            doc_back__image = np.array(doc_back_pil_image_format)

        doc_front_image_bytes = doc_front_image.flatten().tostring()
        doc_back_image_bytes = doc_back__image.flatten().tostring()
        front_h, front_w, front_ch = doc_front_image.shape
        back_h, back_w, back_ch = doc_back__image.shape

        doc_front_image_validation = route_utils.validate_image_size(doc_front_img)
        doc_back_image_validation = route_utils.validate_image_size(doc_back_img)
        if not doc_front_image_validation or not doc_back_image_validation:
            return route_utils.set_image_size_exceeds_error()

        ocr_front_back_request = ringpb.rm_back_front_ocr_request(
            doc_front_image=doc_front_image_bytes,
            doc_back_image=doc_back_image_bytes,
            doc_front_img_width=front_w,
            doc_front_img_height=front_h,
            doc_front_img_channels=front_ch,
            doc_back_img_width=back_w,
            doc_back_img_height=back_h,
            doc_back_img_channels=back_ch,
            card_type=constants.aadhaar
        )

        ocr_details = wsgiapp().config['grcp'].GetFrontBackOCR(ocr_front_back_request)
        """
        MessageToDict has been used to convert grpc response object to json
        """
        result = route_utils.set_ocr_front_back_response(MessageToDict(ocr_details.response))
        return result

    except HTTPException:
        error_response = {'error': {'message': "service not found"}, 'status': constants.BAD_REQUEST}

    return route_utils.set_error_respone(error_response)

@grpc_map.route(VERSION_V2 + '/viewimage', methods=['POST'])
def viewimage():
    if LENTRA_AUTHENTICATION_FLAG:
        response = route_utils.authenticate_request(request)
        if response:
            return response
    content = request.get_json()
    if content['request'] != constants.OCR:
        invalid_request = {'error': {'message': "please provide correct request type as ocr"},
                           'status': constants.BAD_REQUEST}
        return route_utils.set_error_respone(invalid_request)
    try:
        client_request = service_schema.OcrRequestSchema().load(content)
    except Exception:
        error_response = {'error': {'message': "Not a valid URL"},
                          "status": constants.BAD_REQUEST}
        return route_utils.set_error_respone(error_response)
    # extension = client_request['data']['url'].split("/")[-1].split('.')[-1]
    if not route_utils.validate_file_formats(client_request['data']['url']):
        error_response = {'error': {'message': f"file format not allowed : {extension}"},
                          "status": constants.BAD_REQUEST}
        return route_utils.set_error_respone(error_response)
    is_valid_format, extension = route_utils.validate_file_formats(client_request['data']['url'])
    if not is_valid_format:
        error_response = {'error': {'message': f"file format not allowed : {extension}"},
                          "status": constants.BAD_REQUEST}
        return route_utils.set_error_respone(error_response)
    url1 = route_utils.get_image_UAT(client_request['data']['url'])
    img = url1.content
    if url1.status_code != constants.OK:
        error_response = {'error': {'message': "Could not fetch URL"}, 'status': constants.BAD_REQUEST}
        return route_utils.set_error_respone(error_response)

    pil_image_format = Image.open(io.BytesIO(img))
    if not pil_image_format.mode == constants.RGB:
        image_array = route_utils.convert_to_RGB(pil_image_format)
        pil_image = Image.fromarray(image_array)
        image = np.array(pil_image)
    else:
        image = np.array(pil_image_format)
    im = Image.fromarray(image)
    buff = io.BytesIO()
    im.save(buff, "JPEG")
    buff.seek(0)
    return send_file(buff, mimetype='image/jpeg')


@grpc_map.route(IQA_V3 + '/iqa', methods=['POST'])
def imagequalityCombinedResult():
    try:
        assert request.method == 'POST'
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        content = request.get_json()
        if content['request'] != constants.IQA:
            invalid_request = {'error': {'message': "please provide correct request type as ocr"},
                               'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(invalid_request)
        try:
            client_request = service_schema.OcrRequestSchema().load(content)
        except Exception:
            error_response = {'error': {'message': "Not a valid URL"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        is_valid_format, extension = route_utils.validate_file_formats(client_request['data']['url'])
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        url1 = route_utils.get_image_UAT(client_request['data']['url'])
        img = url1.content
        if url1.status_code != constants.OK:
            error_response = {'error': {'message': "Could not fetch URL"}, 'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)

        pil_image_format = Image.open(io.BytesIO(img))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)
        img_bytes = image.flatten().tostring()
        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(img)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        iqa_request = ringpb.rm_iqa_request(
            image=img_bytes,
            img_width=w,
            img_height=h,
            img_channels=ch
        )
        iqa_details = wsgiapp().config['grcp'].IQAFitnessCombined(iqa_request)
        if 'error' in MessageToDict(iqa_details):
            response = route_utils.set_error(iqa_details.error)
        else:
            response = {'image_quality': iqa_details.image_quality,
                        'is_bad_brisque_quality': iqa_details.is_bad_brisque,
                        'is_bright_spot_present': iqa_details.is_bright_present, 'is_dull': iqa_details.is_dull,
                        'status_code': constants.OK}

        return response

    except HTTPException:
        error_response = {'error': {'message': "service not found"}, 'status': constants.BAD_REQUEST}
        return route_utils.set_error_respone(error_response)



@grpc_map.route(VERSION_V2 + '/concatenateimage', methods=['POST'])
def concatImgae():
    try:
        assert request.method == 'POST'
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        content = request.get_json()
        if content['request'] != constants.CONCAT:
            invalid_request = {'error': {'message': "please provide correct request type as concat"},
                               'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(invalid_request)
        try:
            client_request = service_schema.GonogoClientRequest().load(content)
        except Exception:
            error_response = {'error': {'message': "Not a valid URL"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        is_valid_format_front, extension = route_utils.validate_file_formats(client_request['data']['url_1'])
        if not is_valid_format_front:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        is_valid_format_back, extension = route_utils.validate_file_formats(client_request['data']['url_2'])
        if not is_valid_format_back:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        start = perf_counter()
        url1 = route_utils.get_image_UAT(client_request['data']['url_1'])
        url2 = route_utils.get_image_UAT(client_request['data']['url_2'])
        end = perf_counter()
        if url1.status_code != constants.OK or url2.status_code != constants.OK:
            error_response = {'error': {'message': "No image found on provided path"}, 'status': url1.status_code}
            return route_utils.set_error_respone(error_response)
        start_pixar = perf_counter()
        doc_front_img = url1.content
        doc_back_img = url2.content

        doc_back_pil_image_format = Image.open(io.BytesIO(doc_back_img))

        doc_front_pil_image_format = Image.open(io.BytesIO(doc_front_img))
        if not doc_front_pil_image_format.mode == constants.RGB:
            image_array = route_utils.convert_to_RGB(doc_front_pil_image_format)
            pil_image = Image.fromarray(image_array)
            doc_front_image = np.array(pil_image)
        else:
            doc_front_image = np.array(doc_front_pil_image_format)

            doc_back_pil_image_format = Image.open(io.BytesIO(doc_back_img))

        if not doc_back_pil_image_format.mode == constants.RGB:
            image_array = route_utils.convert_to_RGB(doc_back_pil_image_format)
            pil_image = Image.fromarray(image_array)
            doc_back__image = np.array(pil_image)
        else:
            doc_back__image = np.array(doc_back_pil_image_format)

        doc_front_image_bytes = doc_front_image.flatten().tostring()
        doc_back_image_bytes = doc_back__image.flatten().tostring()
        front_h, front_w, front_ch = doc_front_image.shape
        back_h, back_w, back_ch = doc_back__image.shape

        doc_front_image_validation = route_utils.validate_image_size(doc_front_img)
        doc_back_image_validation = route_utils.validate_image_size(doc_back_img)
        if not doc_front_image_validation or not doc_back_image_validation:
            return route_utils.set_image_size_exceeds_error()


        front_edge_request = ringpb.rm_img_edge_request(
            image=doc_front_image_bytes,
            image_width=front_w,
            image_height=front_h,
            image_channels=front_ch
        )
        front_img_responses = wsgiapp().config['grcp'].ImgEdgeDetection(front_edge_request)
        list_co_ordinates = front_img_responses.response.boxes
        front_img_bytes = front_img_responses.response.image
        front_h, front_w, front_ch = front_img_responses.response.image_height, front_img_responses.response.image_width, front_img_responses.response.image_channels
        front_croped_image = route_utils.egde_detector_response(list_co_ordinates, front_img_bytes, front_h, front_w,
                                                                front_ch, doc_front_image)


        back_edge_request = ringpb.rm_img_edge_request(
            image=doc_back_image_bytes,
            image_width=back_w,
            image_height=back_h,
            image_channels=back_ch
        )
        back_img_responses = wsgiapp().config['grcp'].ImgEdgeDetection(back_edge_request)
        list_co_ordinates = back_img_responses.response.boxes
        back_img_bytes = back_img_responses.response.image
        back_h, back_w, back_ch = back_img_responses.response.image_height, back_img_responses.response.image_width, \
                                  back_img_responses.response.image_channels
        back_croped_image = route_utils.egde_detector_response(list_co_ordinates, back_img_bytes, back_h, back_w,
                                                               back_ch, doc_back__image)
        front = route_utils.expand2square(Image.fromarray(front_croped_image), (255, 255, 255))
        back = route_utils.expand2square(Image.fromarray(back_croped_image), (255, 255, 255))
        front_croped_image = np.array(front)
        back_croped_image = np.array(back)
        if constants.CONCAT_DIRECTION == constants.H:
            img = route_utils.hconcat_resize_min([front_croped_image, back_croped_image])
        if constants.CONCAT_DIRECTION == constants.V:
            img = route_utils.vconcat_resize_min([front_croped_image, back_croped_image])
        im = Image.fromarray(img)
        # im.save("/home/ssg0283/Desktop/c/concate"+"_"+constants.CONCAT_DIRECTION+".jpg")
        buff = io.BytesIO()
        if im.mode == constants.RGB:
            im.save(buff, "JPEG")
            mimetype = 'image/jpeg'
        else:
            im.save(buff, "PNG")
            mimetype = 'image/png'
        encoded_string = base64.b64encode(buff.getvalue())
        result = {"concat_image": encoded_string.decode("utf-8")}

        #buff.seek(0)
        return result

    except HTTPException:
        error_response = {'error': {'message': "service not found"}, 'status': constants.BAD_REQUEST}

    return route_utils.set_error_respone(error_response)

@grpc_map.route(VERSION_V4+ '/aadhaarfrontback',methods = ['POST'])
def frontbackocr():
    try:
        assert request.method == 'POST'
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        content = request.get_json()
        if content['request'] != constants.OCR:
            invalid_request = {'error': {'message': "please provide correct request type as ocr"},
                               'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(invalid_request)
        try:
            client_request = service_schema.OcrRequestSchema().load(content)
        except Exception:
            error_response = {'error': {'message': "Not a valid URL"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)

        is_valid_format, extension = route_utils.validate_file_formats(client_request['data']['url'])
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)

        url1 = route_utils.get_image_UAT(client_request['data']['url'])
        img = url1.content
        if url1.status_code != constants.OK:
            error_response = {'error': {'message': "Could not fetch URL"}, 'status': constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)

        pil_image_format = Image.open(io.BytesIO(img))
        if not pil_image_format.mode == constants.RGB:
            image_array=route_utils.convert_to_RGB(pil_image_format)
            pil_image = Image.fromarray(image_array)
            image = np.array(pil_image)
        else:
            image = np.array(pil_image_format)
        if IMAGE_MODE == constants.BGR:
            image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)

        try:
            h, w, ch = image.shape
        except:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        if not ch == constants.IMAGE_CHANEEL:
            return route_utils.set_error_respone(constants.NOT_THREE_CHANEL_IMAGE)
        image_validation = route_utils.validate_image_size(img)
        if not image_validation:
            return route_utils.set_image_size_exceeds_error()

        doc_front_image ,doc_back__image = route_utils.split_image(image)
        doc_front_image_bytes = doc_front_image.flatten().tostring()
        doc_back_image_bytes = doc_back__image.flatten().tostring()
        front_h, front_w, front_ch = doc_front_image.shape
        back_h, back_w, back_ch = doc_back__image.shape


        ocr_front_back_request = ringpb.rm_back_front_ocr_request(
            doc_front_image=doc_front_image_bytes,
            doc_back_image=doc_back_image_bytes,
            doc_front_img_width=front_w,
            doc_front_img_height=front_h,
            doc_front_img_channels=front_ch,
            doc_back_img_width=back_w,
            doc_back_img_height=back_h,
            doc_back_img_channels=back_ch,
            card_type=constants.aadhaar
        )

        ocr_details = wsgiapp().config['grcp'].GetFrontBackOCR(ocr_front_back_request)
        """
        MessageToDict has been used to convert grpc response object to json
        """
        result = route_utils.set_ocr_front_back_response(MessageToDict(ocr_details.response))
        return result

    except HTTPException:
        error_response = {'error': {'message': "service not found"}, 'status': constants.BAD_REQUEST}

    return route_utils.set_error_respone(error_response)

#for Local use
@grpc_map.route(VERSION_V2+'/saveImage', methods=['POST'])
def saveimage():
    try:
        directory = "/home/ssg0283/Documents/ImageData/TestImages"

        assert request.method == 'POST'
        content = request.get_json()

        client_request = service_schema.OcrRequestSchema().load(content)
        if not os.path.exists(directory):
            os.makedirs(directory)
        else:
            img1= os.path.join(directory, client_request['data']['url'].split('/')[-1])
            with open(img1, 'wb') as f1:
                try:
                    url1 = route_utils.get_image_UAT(client_request['data']['url'])
                    img = url1.content
                    f1.write(url1.content)

                except Exception as e:
                    print("ERROR",str(e))

                #f1.write(url1.content)
                #f2.write(url2.content)
        return {"saved"}

    except Exception as e:
        print(str(e))


@grpc_map.route(VERSION_V1 + '/test', methods=['POST', 'OPTIONS'])
@cross_origin()  # allow all origins all methods.
def test():
    if len(request.files) > 0:
        image = request.files['file']
        filename = image.filename
        is_valid_format, extension = route_utils.validate_file_formats(filename)
        if not is_valid_format:
            error_response = {'error': {'message': f"file format not allowed : {extension}"},
                              "status": constants.BAD_REQUEST}
            return route_utils.set_error_respone(error_response)
        if not image:
            return route_utils.set_no_file_response()
        if LENTRA_AUTHENTICATION_FLAG:
            response = route_utils.authenticate_request(request)
            if response:
                return response
        image_array = image.read()
        start = perf_counter()
        pil_image_format = Image.open(io.BytesIO(image_array))
        end = perf_counter()
        startnp = perf_counter()
        image = np.array(pil_image_format)
        endnp = perf_counter()
        bytetopil = round((end-start),4)
        timenp = round((endnp-startnp),4)
        totaltime = round((endnp-start),4)

        return jsonify({'byteToPILImage': bytetopil, 'pilToNumpy': timenp, 'totalTime':totaltime})

        # if not pil_image_format.mode == constants.RGB:
        #     image_array=route_utils.convert_to_RGB(pil_image_format)
        #
        #     pil_image = Image.fromarray(image_array)
        #     image = np.array(pil_image)
        # else:
        #     image = np.array(pil_image_format)


@grpc_map.route('/matcher',methods = ['POST'])
def stringmatch():
    assert request.method == 'POST'
    content = request.get_json()
    version = request.headers['version']
    if version == 'v1':
        client_request = service_schema.MatcherRequest().load(content)
        string_1 = client_request['data']['string_1']
        string_2 = client_request['data']['string_2']
        matcher_response = route_utils.matcherResponse(string_1,string_2)
        return jsonify(matcher_response)
    else:
        client_request = service_schema.MatcherRequestV2().load(content)
        address1_details = client_request['data']['address1']
        address2_details = client_request['data']['address2']
        response = route_utils.mandetory_fields_check(address1_details,address2_details)
        if response:
            result = {'address_match':False}
            result.update(response)
            return jsonify(result)
        match_mandatory_details = route_utils.match_mandatory_details(address1_details,address2_details)
        if match_mandatory_details:
            result = {'address_match': False}
            result.update(match_mandatory_details)
            return jsonify(result)
        dipper_address=route_utils.check_address_dipper(address1_details,address2_details)
        result = {'address_line1':dipper_address['remark']['address_1'],
                 'address_line2':dipper_address['remark']['address_2'],
                 'state':'match',
                 'city': 'match',
                  'pin': 'match'
                 }
        if 'no match' in result:
            moified_result = {'address_match': False}
            moified_result.update({"reamrk":result})
        else:
            moified_result = {'address_match': True}
            moified_result.update({'remark':result})
        return  jsonify(moified_result)

@grpc_map.route('/emailvalidator',methods = ['POST'])
def validatemail():
    assert request.method == 'POST'
    content = request.get_json()
    client_request = service_schema.ValidEmail().load(content)
    email_string = client_request['data']['email_id']
    validation = route_utils.email_validation(email_string)
    return jsonify(validation)


@grpc_map.route('/credit_risk',methods = ['POST'])
def credit():

    if len(request.files) > 0:
        file = request.files['file']
        features = (file.read()).decode("utf-8").split('\n')
        listss=[sub.split(",") for sub in features]
        features_df = pd.DataFrame(listss[1:],columns=listss[0])
        credit_results = route_utils.get_results(features_df)
        credit_results.to_csv(CREDIT_CSV_PATH, sep=',', encoding='utf-8')
        return jsonify({'remark ':'file saved successfully'})

@grpc_map.route('/credit_risk2',methods = ['POST'])
def credit2():

    if len(request.files) > 0:
        file = request.files['file']
        features = (file.read()).decode("utf-8").split('\n')
        listss=[sub.split(",") for sub in features]
        features_df = pd.DataFrame(listss[1:],columns=listss[0])
        credit_results = route_utils.get_results(features_df)
        credit_results.to_csv(CREDIT_CSV_PATH, sep=',', encoding='utf-8')
        return jsonify(credit_results.to_dict())

@grpc_map.route('/cd-ntc',methods = ['POST'])
def client_script():
    assert request.method == 'POST'
    content =dict(request.form)
    listst=[]
    keys = ','.join(list(content.keys()))
    values = ','.join(list(content.values()))
    listst.insert(0,keys.split(','))
    listst.insert(1, values.split(','))
    features_df = pd.DataFrame(listst[1:], columns=listst[0])
    credit_results = route_utils.get_weight_of_evidences_single_record(features_df)
    return jsonify(credit_results.to_dict())



@grpc_map.route('/csvToJson',methods = ['POST'])
def csvtojson():
    if len(request.files) > 0:
        file = request.files['file']
        features = (file.read()).decode("utf-8").split('\n')
        listss=[sub.split(",") for sub in features]
        features_df = pd.DataFrame(listss[1:],columns=listss[0])
        json_file = route_utils.convert_to_json_mobile(features_df)
        import json

        with open('/home/ssg0283/Documents/RISK_MODELS/CD_NTCMobilegroup_dict.json', 'w') as fp:
            json.dump(json_file, fp)
        return jsonify({'remark ': 'file saved successfully'})



if __name__ == '__main__':
    wsgiapp().run(port=5000, host="0.0.0.0")
